<?php
/* 1. Какие типы паттернов проектирования существуют?

Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
Структурные паттерны показывают различные способы построения связей между объектами.
Поведенческие паттерны заботятся об эффективной коммуникации между объектами.
*/

/*
2. Как можно улучшить Singleton при помощи trait-ов?

Сделать Singletone trait-ом, и добавлять к любому классу, если есть необходимость
*/

Trait SingletonTrait
{
    private static $instance;

    public static function getInstance()
    {
        if (empty(self::$instance)) self::$instance = new static();

        return self::$instance;
    }

    private function __construct()
    {
    }
    private function __clone()
    {
    }
    private function __wakeup()
    {
    }
}

class С
{
    use SingletonTrait;

    private $a = [];

    public function addB($b)
    {
        $this->a[] = $b;
    }
}

$a1 = A::getInstance();
$a1->addB('one');


/*
3. Как реализуется паттерн Фабричный метод? В чем его отличие от паттерна Фабрика?
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанциировать.
Фабричный метод позволяет классу делегировать создание подклассов.
Отличие в том, что Фабрика это семейство классовав, а фабричный метод это интерфейс создания одного объекта.
*/

/*
4. Объясните назначение и применение магических методов __get, __set, __isset, __unset, __call и __callStatic.
Когда, как и почему их стоит использовать (или нет)?

__get() отслеживает обращения к любым непубличным свойствам.
__set() аналогично __get() отслеживат попытки изменить данные непубличного свойстваю
__isset() отслеживает вызов функции на проверку существования и получает в качестве аргумента — название свойства.
__unset() отслеживает попытки очистить не публичный свойства класса.
 __call() перехватывает все попытки вызовов методов, не являющихся публичными,
__callStatic() - при обращении к статическому члену класса.
Вызывать эти методы напрямую не надо, PHP будет вызывать их каждый раз, при попытке обращения к не публичным свойствам класса.
Их использование позволяют инкапсулировать реализацию от внешнего мира.В совокупности эти методы улучшают возможности для гибкой композиции.
Степень абстракции объектов, инкапсуляция, компактность кода повышается, но есть и ряд недостатков, например, медленное выполнение
магических методов. Поэтому ответить навопрос о том, стоит ли использовать магические методы, однозначно ответить нельзя.
Достоинства и недостатки нужно оценивать в каждом конкретном случае.
*/

/*
5. Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.
SplDoublyLinkedList — Двусвязные списки. Каждый узел такого списка хранит ссылку на предыдущий и на следующий за ним узел.
Двусвязный список позволяет эффективно обходить и добавлять большие наборы данных без необходимости повторного хеширования.

SplStack — Стек
SplQueue — Очередь
очень похожи на SplDoublyLinkedList. Обе эти структуры, по сути, представляют собой двусвязные списки с разными флагами
итераторов(IT_MODE_LIFO – Last In First Out – последним пришёл, первым ушёл; и IT_MODE_FIFO – First In First Out – первым
пришёл, первым ушёл), которые регулируют порядок обработки узлов и что делать с этими элементами после того, как они будут обработаны.
Ещё одно отличие между этими структурами заключается в том, что интерфейс SplQueue содержит более интуитивно понятные методы enqueue()
и dequeue() в отличие от методов push() и pop() у SplStack.

SplFixedArray – массив фиксированной длины, индексами которого могут быть только целые числа. Эти ограничению обеспечивают
 более высокую скорость обработки массива, которая достигается, в том числе, благодаря тому, что в SplFixedArray нет хеширования
ключей элементов при их добавлении (в отличие от обычных массивов).
*/

/*
6. Найдите все ошибки в коде:

interface MyInt {
    public function funcI();
    private function funcP(); // не может быть private
}
class A {
    protected prop1; //объявление свойства
    private prop2; //объявление свойства

    function funcA(){
       return $this->prop2;
    }
}
class B extends A {
    function funcB(){
       return $this->prop1;
    }
}
class C extends B implements MyInt { //нереализиван в классе метод funcP() из контракта MyInt
    function funcB(){
       return $this->prop1;
    }
    private function funcP(){ // не может быть private, тктимплементирует MyInt
       return 123;
    }
}
$b = new B();
$b->funcA();
$c = new C();
$c->funcI();

*/
interface MyInt {
    public function funcI();
    public function funcP();
}
class A {
    protected $prop1;
    private $prop2;

    function funcA(){
        return $this->prop2;
    }
}
class B extends A {
    function funcB(){
        return $this->prop1;
    }
}
class C extends B implements MyInt {
    function funcB(){
        return $this->prop1;
    }
    function funcP(){
        return 123;
    }

    function funcI()
    {
        // TODO: Implement funcI() method.
    }
}
$b = new B();
$b->funcA();
$c = new C();
$c->funcI();
